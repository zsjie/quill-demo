# 对列表的识别

列表分为有序列表和无序列表，除了对序号的处理不同，其他处理逻辑都差不多。

## markdown 中的列表规则

列表的正则表达式：

```javascript
let list = /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/
let bull = /(?:[*+-]|\d+\.)/
```

为了方便理解，以上的正则都是语义化的。这个正则是对整个列表进行匹配，并没有对列表中的每一项进行匹配。markdown 的处理策略是，先将整个列表区块匹配出来，然后在区块内部匹配每一项。所以这个区块的规则是：

1. 从字符串输入开始的位置进行匹配
2. 开始的标记是 `*+-` 符号中的任意一个加上一个空格或者数字加上一个空格，分别对应无序列表和有序列表。暂且称开始标记为 `bull`
3. `bull` 之前可以有任意个空格，注意这里是用一个捕获组来匹配空格，并且在后面引用了这个捕获组，这和列表的嵌套有关。`bull` 后面必须紧接一个空格
4. 区块中的可以包含任意字符，至少有一个字符。注意 `[\s\S]+?` 这里用了懒惰模式来进行匹配，这是因为 `\s\S` 可以匹配到任何字符，如果使用贪婪模式，那么会将从 `bull` 后面的空格一直到字符输入结束位置之间的字符都匹配进区块中
5. 区块结束的标记有四种情况：
    - 紧接着 hr 格式
    - 紧接着 def 格式
    - 紧接着两个或两以上的换行符
    - 字符输入结束
    
说说 `(?:\n{2,}(?! )(?!\1bull )\n*)` 的作用。这个规则是为两个列表区块之间有多个空行的情况设计的，同时也规定了可以用两个换行符结束：

```javascript
// 对于下面这个字符串
// ( *)(bull) [\s\S]+?(?:\n{2,}(?! )(?!\1bull ) 会匹配到 '-a\n\n'
// 没有匹配到第三个换行符是因为它后面紧跟着 '- '
// 但是 \n* 会匹配第三个换行符
// 所以 '- a\n\n\n' 是一个列表，'- b\n' 是另外一个列表
// 所以说如果说两个列表是相邻的，那么它们之间需要用两个空行来分隔
let list1 = '- a\n\n\n- b\n'

// 对于下面这个字符串
// ( *)(bull) [\s\S]+? 会匹配到 '- a'
// (?:\n{2,}(?! )(?!\1bull ) 无法匹配 '\n\n'
// 因为第二个换行符后面紧跟着 '- '
// 但 b 后面的 '\n\n' 可以匹配到
// 所以如果需要将列表和其他非列表分隔开，需要一个空行
let list2 = '- a\n\n- b\n\ncde'
```
    
## markdown 中 item 的规则

```javascript
let item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/gm

// 来讲一讲这个正则是如何工作的
// 对于下面这个字符串来说
// ^( *)(bull)  会匹配到 '- a' 和 '- d'
// (?:\n(?!\1bull )[^\n]*)* 会匹配到 '\nb\nc'
// 也就是说 item 中出现换行符不一定表示这个 item 结束了
// 除非换行符后面紧跟着 '- '，即除非换行符后面紧跟着下一个 item 开始的标记
// 也就是说，item 的内容可以换行
let list = '- a\nb\nc\n- d\n'
```

在这里补充一下 `m` 搜索标志的知识。很多时候我们可以通过边界符号 (^,$,\b,\B) 达到我们匹配某些字符串的目的。但是如果字符串有多行呢，这个其实很简单了，只需加个 `m` 就指定为多行匹配了。实例：

```javascript
let str = "first second\nthird fourth\nfifth sixth"
let patt = /(\w+)$/gm
console.log(str.match(patt)) // ["second", "fourth", "sixth"]
```

如果没有指定 `m` ，则只会得到 sixth 了，加了 `m` 后实际上正则表达式是把 \n、\r 这些也换行和回车当成边界了，可以这么理解。item 的正则加入 `\m` 是为了将 \n 也当成边界，以达到能准确识别每一个 item 的目的。

item 的规则是：

1. 从字符开始的边界进行匹配
2. 开始的标记是 `*+-` 符号中的任意一个加上一个空格或者数字加上一个空格，分别对应无序列表和有序列表。暂且称开始标记为 `bull`
3. `bull` 之前可以有任意个空格，注意这里是用一个捕获组来匹配空格，并且在后面引用了这个捕获组，这和列表的嵌套有关。`bull` 后面必须紧接一个空格
4. item 的内容可以为空，允许换行，但不允许空行
5. item 结束的标记是另一个 item 开始的标记

## 列表的 delta

```javascript
let delta = new Delta()
    .insert('a')
    .insert('\n', { list: 'bullet' })
    .insert('b')
    .insert('\n', { list: 'bullet' })
```

## 列表的 token

```javascript
let tokens = Lexer.lex('- a\n- b\n')
// [
//   {"type":"list_start","ordered":false},
//   {"type":"list_item_start"},
//   {"type":"text","text":"a"},
//   {"type":"list_item_end"},
//   {"type":"list_item_start"},
//   {"type":"text","text":"b"},
//   {"type":"list_item_end"},
//   {"type":"list_end"}
// ]
```

## 处理内容换行的问题

从上面的分析可以看出，在 markdown 中，item 的内容是可以换行，但在 quill 中 item 内容是不允许换行的，所以我们现在要解决这个问题。方案是，修改 list 和 item 规则，使在 markdown 中 item 内容也不能换行。

要处理的第一种情况，列表中的空行。在一般 markdown 中，以下这段文字会被识别为同一个列表：

```
- a

- b
```

第二种情况，在 item 中换行。在一般 markdown 中，以下这段文字也会被识别为同一个列表：

```
- a
b
- c
```

我们要修改对上面这两种情况的匹配规则，使它们也成为列表区块的结束标记。

正则修改如下：

```javascript
let list = /^( *)(bull) [\s\S]+?(?:hr|def|\n(?!\1bull )|\s*$)/
```
  
